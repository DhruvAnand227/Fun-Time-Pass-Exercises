// 3 Methods to build a simple rate limiter

// Function to give gap
async function sleep(timeInMS) {
  return await new Promise((res) => {
    setTimeout(() => {
      res();
    }, timeInMS);
  })
}

// Sliding Window logic
const userTimeMap = new Map();

function canSendMessage(userID, timeStamp) {
  if (!userTimeMap.has(userID)) {
    userTimeMap.set(userID, []);
  }

  const queue = userTimeMap.get(userID);

  while (queue.length > 0 && timeStamp - queue[0] >= 1000) {
    queue.shift();
  }

  if (queue.length >= 3) {
    console.log("Too Many Requests");
    return;
  }

  queue.push(timeStamp);
  console.log("Message Sent");
}

canSendMessage("nonu", 0);
canSendMessage("nonu", 200);
canSendMessage("nonu", 980);
canSendMessage("nonu", 990);


//Leaky Bucket rate limiter
const messages = new Map();
const LEAK_RATE = 3;
const LEAK_INTERVAL = 1000;

async function leakyBucket(userID, messageArray) {
  if (!messages.has(userID)) {
    messages.set(userID, []);
  }

  let queue = messages.get(userID);
  for (const message of messageArray) {
    queue.push(message);
  }

  while (queue.length > 0) {

    const msgToSent = Math.min(LEAK_RATE, queue.length);

    for (let i=0; i<msgToSent; i++) {
      const msgSent = queue.shift();
      console.log(`${msgSent} --> sent`);
      await sleep(100);
    }

    console.log('\n');

    await sleep(LEAK_INTERVAL);
  }

  // Each second only 3 messages maximum can be sent;
  await sleep(1000);
}

leakyBucket("dhruv", ["hi", "bye", "jaaye", "laaye", "Khaaye"]);



// Token Bucket
const tokenBucketMap = new Map();
const BUCKET_CAPACITY = 3;
const REFILL_RATE = 3; // 3 tokens per second

async function sleep(ms) {
  return new Promise(res => setTimeout(res, ms));
}

async function tokenBucket(userID, messageArray) {
  // Create bucket if not exist
  if (!tokenBucketMap.has(userID)) {
    tokenBucketMap.set(userID, {
      tokens: BUCKET_CAPACITY,
      lastRefill: Date.now()
    });
  }

  const bucket = tokenBucketMap.get(userID);

  // Add messages to queue
  const queue = [...messageArray];

  while (queue.length > 0) {

    // STEP 1: refill tokens based on time passed
    const now = Date.now();
    const timePassed = now - bucket.lastRefill;

    if (timePassed >= 1000) {
      bucket.tokens = Math.min(
        BUCKET_CAPACITY,
        bucket.tokens + REFILL_RATE
      );
      bucket.lastRefill = now;
    }

    // STEP 2: check if tokens exist
    if (bucket.tokens === 0) {
      console.log("No tokens left, waiting...");
      await sleep(100);
      continue;
    }

    // STEP 3: send message
    const msg = queue.shift();
    bucket.tokens--;
    console.log(`${msg} --> sent`);
    await sleep(100);
  }
}
